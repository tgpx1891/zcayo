## 软件测试

### 软件测试定义

通过手工或者工具对“被测对象”进行测试操作，从而验证实际结果与预期结果之间是否存在差异。软件测试是通过考虑软件的所有属性(可靠性，可伸缩性，可移植性，可重用性，可用性)和评估软件组件的执行来查找软件错误或缺陷来识别软件正确性的过程

### 软件开发生命周期（SDLC）

1. 需求阶段
2. 设计阶段
3. 建设/发展阶段
4. 测试阶段
5.  部署/交付阶段
6. 维护阶段

### 软件测试生命周期（STLC）

1. 需求分析

2. 测试计划创建

3. 环境设置

4. 测试用例执行

   RTM(需求可追溯性矩阵)也在此阶段准备。需求可跟踪性矩阵是行业级格式，用于跟踪需求

5. 缺陷记录

6. 测试周期关闭

软件质量保证（QA）：是一组活动，可确保始终保持软件开发过程中使用的过程质量

质量控制（QC）：是一组用于检测已开发软件中的缺陷的活动

### 测试级别

1. 单元测试（UT）

   在软件测试中单元指的就是组成软件最小的底层代码结构，一般就是类、函数、组件

2. 集成测试（IT system ingertation test）

   将多个单元模块组合在一起，然后验证他们之间沟通的“桥梁”是否能正常工作（接口测试）

3. 系统测试（ST）

   当前行业做的最多的一种测试，由测试人员充当用户对软件的功能主体进行测试

4. 验收测试

   核心就是让用户为当前软件“买单”

   （1）α测试——内侧

   （2）β测试——公测

   （3）UTA测试（user acceptance test）：由客户派出对于业务非常精通的人员来使用该软件，从而对功能进行测试

### 测试原则

1. 测试证明软件存在缺陷
2. 不能执行穷尽测试
3. 某些测试需要依赖特殊的环境
4. 测试应尽早介入
5. 杀虫剂现象
6. 不存在缺陷谬论

### 测试对象

对于当前的测试行业来说我们最经常测试的主体就是软件（主体功能），但是需要我们明白软件也不仅仅只有功能需要测试，可以将软件分为三个组成部分：功能集合、使用说明书、配置数据

1. 需求分析阶段：各种需求规格说明书
2. 软件架构设计：API接口文档（接口测试）
3. 编码实现阶段：源代码（白盒测试、单元测试）
4. 系统功能使用：软件功能主体（当前行业做的最多的一种测试）

### 常见系统测试方法

一、按测试对象进行分类（是否查看源代码）

1. 白盒测试

   把盒子打开研究里面的程序结构和源代码，这种测试的主体就是软件的底层代码，不会在意外在的界面是否OK，只要求底层功能实现，同时逻辑正确

2. 黑盒测试：这种测试就是指测试软件外在主体功能是否可用

3. 灰色测试：介于两者之间（接口测试）

二、按测试对象是否执行分类

1. 静态测试：测试不执行

2. 动态测试：将软件运行在真实的使用环境中进行测试


三、按测试手段进行分类

1. 手工测试：由测试人员手动地对被测对象进行验证，优点就是可以灵活地改变测试操作及环境
2. 自动化测试：自动化主要有两种形式，一是自己写测试脚本，另外就是通过第三方的工具对被测对象进行测试，优点就是可以高效地去执行一些人工无法实现的操作

四、其它测试

1. 回归测试
2. 冒烟测试
3. 随机测试：针对重要功能、心增加的功能、特殊情况、以前发现过重大bug的模块进行二次测试
4. 验收测试

测试用例：测什么，怎么测

### 软件质量

1. 功能性：软件需要满足用户显式或者隐式的功能
2. 易用性：软件易于学习和上手使用
3. 可靠性：软件必须实现需求当中的具体功能
4. 效率性：软件的性能
5. 可维护性：要求软件具有将某个功能修复之后继续使用的能力
6. 可移植性：当前软件可以从一个平台移植到另一个平台上去使用的能力

### 软件架构

软件架构我们可以理解为是用来指导我们软件开发的一种思想，目前最常见的两种架构模式就是B/S和C/S（browser、client、server）

#### 两种架构的比较

1. 相对于CS架构来说BS架构的两端都是在使用现成的成熟产品，所以BS会显示得标准一些
2. 相对于BS架构来说CS中的客户端可以分担一些数据的处理，因此执行效率会高一些
3. BS架构当中的数据传输都是以HTTP协议进行的输出，而HTTP协议又是明文输出，可以被抓包，所以相对于CS架构来说BS架构就显得不那么安全
4. BS架构只需要在服务器端将数据进行更新，前台只需要刷新页面就可以完成升级，而CS架构当中必须要将两端都进行更新
5. 相对于BS架构来说CS当中的客户端需要自己开发，所以相对来说成本会高一些

### 软件测试流程

1. 需求分析

   当前阶段的核心目的就是梳理清楚我们需要设计的点是什么需求的来源：有需求规格说明书、API文档、竞品分析、个人经验

2. 设计用例

   用例就是用户为了测试软件的某个功能而执行的操作过程

3. 评审用例

   对当前的用例进行添加或者删除

4. 配置环境

   指的就是当前被测对象运行所需要的执行环境，作为测试人员需要具备配环境的能力（一般情况下都会使用一件安装的集成环境）

5. 执行用例

   一般在执行用例之前我们都会做一个冒烟测试，这种测试的核心就是快速地对当前软件的核心功能或者主体执行流程进行验证，如果冒烟测试阶段有问题，则可以将此版本退回给开发，只有通过才会展开全面的测试

6. 回归测试及缺陷跟踪

   指的是当我们将某个缺陷提交给开发之后，由他们进行修复，修复完成之后需要测试人员再次对其进行测试；缺陷跟踪指的就是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪

7. 输出测试报告

   当前的测试过程中产生的数据进行可视化的输出

8. 测试结束

   将整个测试过程中产生的一些文档进行整理归档，方便后续版本使用

## 各种开发模型

### 瀑布模型

需求分析>设计>编码>实现>软件测试>完成>维护

各个阶段比较清晰，适合稳定需求的产品开发

### 快速原型模型

快速分析>需求说明>检查原型>原型>运行原型>评价原型>修改意见

适合不能确定需求的软件，不适合开发大型系统

### V模型

![1569079979191](https://massionter-images-1258860804.cos.ap-guangzhou.myqcloud.com/zcayo/1569079979191.png)

1. 单元测试

2. 集成测试

3. 系统测试

4. 验收测试

### W模型

![1569083749135](https://massionter-images-1258860804.cos.ap-guangzhou.myqcloud.com/zcayo/1569083749135.png)

总结：V模型适用于中小企业，W模型适用于中大型企业（因为人员要求高），H模型人员要求非常高，很少有公司使用

### 自顶向下测试

是从程序的初始模块开始测试。

- 该方法会在早期发现顶层的错误。

- 早期的程序框架可以进行演示

- 需要开发桩模块辅助测试。有些甚至需要多个桩模块辅助，加大了桩模块本来的错误影响。

- 测试完一个上层模块后，挑选哪个模块作为下一个测试模块，以及测试的顺序没有唯一的界定标准。

**优点**：较早地验证了主要控制和判断点；按深度优先可以首先实现和验证一个完整的软件功能；功能较早证实，带来信心；只需一个驱动，减少驱动器开发的费用；支持故障隔离。

**缺点**：柱的开发量大；底层验证被推迟；底层组件测试不充分。

### 自底向上测试

是从程序的底层模块开始测试。

- I/O操作可以提前测试，更好提交测试用例。

- 测试后比较容易观察输出。

- 需要开发驱动模块。

- 直到最后一个模块提交，程序才能完整的系统测试。


**优点**：对底层组件行为较早验证；工作最初可以并行集成，比自顶向下效率高；减少了桩的工作量；支持故障隔离。

**缺点**：驱动的开发工作量大；对高层的验证被推迟，设计上的错误不能被及时发现。

( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)
机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器

## 黑盒测试

又称数据驱动测试，完全不考虑程序内部结构和内部特性，注重于测试软件的功能需求，只关心软件的输入数据和输出数据

- 功能测试
  1. 逻辑功能测试
  2. 界面测试
  3. 易用性测试
  4. 安装测试
  5. 兼容性测试
- 性能测试
  1. 时间性能
  2. 空间性能
  3. 一般性能测试
  4. 稳定性测试
  5. 负载测试
  6. 压力测试

| 编号 | 技术                                                         | 描述说明                                                     |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | [决策表技术](http://www.yiibai.com/software_testing/decision-table-technique-in-black-box-testing.html) | 决策表技术是一种系统方法，以表形式捕获各种输入组合及其各自的系统行为。它适用于在两个和两个以上输入之间具有逻辑关系的函数 |
| 2    | 边界值问题技术                                               | 边界值技术用于测试边界值，边界值是包含变量上限和下限的边界值。它在输入边界值时测试软件是否产生正确的输出 |
| 3    | 状态转换技术                                                 | 状态转换技术用于在向同一功能提供不同的输入值时捕获软件应用程序的行为。它适用于那些提供访问应用程序的特定尝试次数的应用程序类型 |
| 4    | 成对测试技术                                                 | 成对测试技术用于测试所有可能的离散值组合。这种组合方法用于测试使用复选框输入，单选按钮输入，列表框，文本框等的应用程序 |
| 5    | 因果技术                                                     | 因果技术强调了给定结果与影响结果的所有因素之间的关系。它基于一系列要求 |
| 6    | 等价类划分技术                                               | 等价类划分是一种软件测试技术，其输入数据被划分为有效值和无效值的分区，并且所有分区必须表现出相同的行为 |
| 7    | 错误猜测技术                                                 | 错误猜测是一种没有用于识别错误的特定方法的技术。它基于测试分析师的经验，测试人员使用该经验来猜测软件的有问题区域 |
| 8    | 用例技术                                                     | 用例技术用于根据系统的使用情况从系统的开头到结尾识别测试用例。通过使用这种技术，测试团队创建了一个测试场景，可以从头到尾根据每个功能的功能运行整个软件 |

### 等价类划分法

属于黑盒测试，他将不能穷举的测试过程进行分类，从而保证完整性和代表性。

等价划分的原则是，测试用例应设计为至少覆盖每个分区一次。每个等效分区的每个值必须表现出与其他分区相同的行为

### 边界值分析法

用于测试边界值，因为边界附近的输入值具有较高的误差机会

边界值分析获得测试用例的方法
使所有变量取正常值，只使一个变量取极值；
对于一个n变量函数，边界值分析会产生4n+1个测试用例。

健壮性测试是作为边界值分析的一个简单的扩充，它除了对变量的5个边界值分析取值外，还需要增加一个略大于最大值(max+)以及略小于最小值(min-)的取值，检查超过极限值时系统的情况。因此，对于有n个变量的函数采用健壮性测试需要6n+1个测试用例

如果是闭区间，例如[1,10]，取上点1、10，内点5，外点0、11；如果是开区间，例如（1,10），取上点1、10，内点5，离点2、9；如果是半开半闭区间，例如（1,10]，取上点1、10，内点5，外点2、11

### 因果图法

#### 约束条件

- 互斥：最多有一个可能成立
- 包含：至少有一个必须成立
- 屏蔽：a成立时b不成立
- 唯一：三个原因中有且只有一个成立
- 要求：一个出现另一个一定出现

**步骤总结：**

- 画出效果和原因的圆圈。
- 从效果开始，然后选择导致此效果的原因。
- 最后绘制相互排斥的原因(通过一种效应和一种原因直接连接的独占原因)。
- 使用逻辑门绘制动态测试用例

### 判定表法（决策表）

- 条件桩：问题的所有条件
- 动作桩：问题的所有输出
- 条件项：针对条件桩的取值
- 动作项：针对动作桩的取值

可以使用`2^n`公式找到所有可能条件的数量，找到所有可能条件的数量，其中`n`表示输入的数量

#### 书写步骤

1. 列出所有条件和动作桩
2. 列出条件和动作桩中的项目
3. 简化判定表

### 场景法

主要用来测试业务流程，分为基本流（正确流程）和备选流（错误流程）

注意：还有补充一些异常情况，在冒烟测试主要用到场景法

### 流程分析法

适用于有先后顺序的测试；常用于业务流程、安装流程等等；每个流程就是一条测试用例，它只是在测试整体流程是否正确，细节还需要使用等价类、边界值等方法进行完善

### 错误推测法

凭着直觉和经验来设计测试用例的，它是根据之前项目相关的bug数据总结来的

### 正交表法

从全面试验中挑选出有代表性的点进行测试（均匀分散，整齐可比）

比如L9（34），有4个控件，每个控件有三个取值，9为需要测试的组合个数（4为上标，9为下标）

使用方法

1. 根据控件和取值数选择一个合适的正交表
2. 例举取值并编号，生成取值表
3. 把取值表与选择的正交表进行映射

正交表生成工具allpairs

先用表格制作取值表，然后复制到文本文档中保存到解压文件夹，命令行进入解压文件夹，输入如下命令

```
allpairs.exe Test.txt>Test1.txt
```

### 测试方法的选择

1. 如果测试功能和流程，要使用场景法
2. 需要输入数据的地方，我们要使用等价类划分法，要注意配合边界值法来做详细测试
3. 如果有条件组合的情况，我们要使用因果图制作出判定表
4. 配置类软件，组合比较多的，我们要使用正交表来科学地使用测试用例
5. 如果没有达到覆盖标准，就要增加一些测试用例
6. 依靠经验追加一些测试用例（错误推断法）

## 白盒测试

白盒测试的测试用例源自软件开发生命周期的设计阶段。

| 测试    技术 | 描述                                                         |
| :----------- | ------------------------------------------------------------ |
| 数据流测试   | 数据流测试是一组测试策略，用于检查程序的控制流程，以便根据事件的顺序探索变量的顺序 |
| 控制流程测试 | 控制流测试通过控制结构确定语句或程序指令的执行顺序。程序的控制结构用于开发程序的测试用例。在该技术中，测试者选择大程序的特定部分来设置测试路径。测试用例由程序的控制图表示 |
| 分支覆盖测试 | 分支覆盖技术用于覆盖控制流图的所有分支。它至少涵盖决策点的每个条件的所有可能结果(真实和错误) |
| 语句覆盖测试 | 语句覆盖技术用于设计白盒测试用例。该技术涉及至少执行一次源代码的所有语句。它用于计算源代码中执行语句的总数，在源代码中存在的总语句中 |
| 决策覆盖测试 | 此技术报告布尔表达式的真假结果。每当语句中有两个或多个结果的可能性时，如 while 语句，if 语句和 case语句(控制流语句)，这些都视为决策点，因为有两个结果为`true`或`false` |

### 数据流测试

数据流测试用于分析程序中的数据流，它是收集有关变量如何在程序中流动数据的过程，试图获得过程中每个特定点的特定信息

### 控制流程测试

控制流图由节点，边缘，决策节点，结节点形成，以指定所有可能的执行路径

- 节点：控制流程图中的节点用于创建过程路径
- 边缘：控制流图中的边用于链接节点的方向
- 决策节点：控制流程图中的决策节点用于根据值确定过程的下一个节点
- 连接节点：控制流图中的结点节点是至少三个链路相遇的点

### 分支覆盖测试

分支覆盖技术和决策覆盖技术非常相似，但两者之间存在关键差异。决策覆盖技术涵盖每个决策点的所有分支，而分支测试涵盖代码的每个决策点的所有分支

### 语句覆盖测试

### 决策覆盖测试

## 其它测试

### 系统测试

- 回归测试
- 负载测试
- 恢复测试
- 迁移测试
- 可用性测试
- 软件和硬件测试

#### 分类

1. 功能测试：验证当前的软件主体功能是否可用
2. 兼容性测试：验证当前软件在不同的环境下是否还可以使用
3. 安全测试：验证是否只是对授权用户提供功能
4. 性能测试：相对于当前软件消耗的资源的产出能力

### 功能测试

单元测试，集成测试，用户验收测试，烟雾/健全测试

### 非功能测试

用于测试非功能性参数，例如：软件的可靠性，负载，安全，可移植性，性能和责任制

### 性能测试

 性能测试，就是模仿用户对一个系统进行大批量的操作，得出系统各项性能指标和性能瓶颈，并从中发现存在的问题，通过多方协助调优的过程。而 web 端的性能测试应该注意的指标有：用户操作的响应时间、系统的吞吐量（TPS）、系统的硬件资源情况（CPU、硬盘、磁盘）、网络资源占用情况等

### 负载测试

负载测试是一种通过增加负载来评估组件或系统的性能的测试方法。例如：通过增加并发用户数和（或）事务数量来测量组件或系统能够承受的负载。通过负载测试来确定在各种工作负载下，系统各项性能指标的变化情况

### 压力测试

压力测试是评估系统处于或超过预期负载时系统的运行情况。压力测试的关注点在于系统在峰值负载或超出最大载荷情况下的处理能力。通过确定一个系统的瓶颈或者刚好不能接受的性能点，来获得系统能够提供的最大服务级别

#### 怎么进行压力测试

1. 首先对要测试的系统进行分析，明确需要对那一部分做压力测试，比如秒杀，支付
2. 如何对这些测试点进行施压。第一种方式可以通过写脚本产生压力机器人对服务器进行发包收包操作，第二种是借助一些压力测试工具比如 Jmeter，LoadRunner
3. 如何对这些测试点进行正确的施压。需要用压力测试工具或者其他方法录制脚本，模拟用户的操作
4. 对测试点设计多大的压力比较合适？需要明确压力测试限制的数量，即用户并发量
5. 测试结束后如何通过这些数据来定位性能问题。通过测试可以得到吞吐量，平均响应时间等数据，这个数据的背后是整个后台处理逻辑综合作用的结果，这时候就可以先关注系统的 CPU，内存，然后对比吞吐量，平均响应时间达到瓶颈时这些数据的情况，然后就能确认性能问题是系统的哪一块造成的

### 接口测试

接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等

## 软件缺陷

缺陷就是软件的问题，最终表现为没有满足用户的需求

1. 软件未达到规格说明书标明的功能
2. 软件出现了规格说明书中指明不会出现的错误
3. 软件功能超出了规格说明书指明的范围
4. 软件未达到规格说明书虽未指明但应该达到的目标
5. 软件测试人员或用户觉得不好

### 表现形式

1. 功能、特性没有实现或者部分实现
2. 设计不合理、功能不明确、逻辑不清楚或存在矛盾
3. 实际结果和期望结果不同
4. 没有达到规格说明书要求的性能指标
5. 运行出错、奔溃、中断、界面混乱
6. 数据不正确、精度不够、不完整或格式不统一
7. 用户不能接受的其它问题，如存取时间过长、界面不美观
8. 硬件或软件存在其它问题

### 软件缺陷的信息

#### 软件缺陷的状态

1. 提交——测试人员提交了一个缺陷给程序员
2. 打开——待处理
3. 拒绝——程序员认为不是缺陷或者重复，就可以修改状态为拒绝
4. 修复——程序员修复缺陷后提交打的一个状态
5. 关闭——测试人员经过回归测试后，认为此缺陷已经解决，将其关闭
6. 推迟——可以放在后续版本解决的问题，但是要详细写出修复的日期或版本

#### 软件缺陷的严重程度划分

1. low——表面性错误，如错别字
2. Medium——影响一个相对独立功能、仅仅发生在特定条件上、与需求定义不一致、断断续续出问题
3. High——功能点没有实现、不符合用户需求、导致数据丢失
4. VeryHigh——频繁死机、大部分功能不能使用
5. Critical——系统瘫痪、异常退出、死循环、严重的计算错误

#### 软件测试的优先级

1. low——时间和资源允许的情况下修复
2. Medium——不会延迟发布，会在以后修复
3. High——会制约开发和测试的进行，需要在发布之前修复
4. VeryHigh——频繁死机、大部分功能不能使用
5. Urgent——导致系统几乎不可用

#### 软件缺陷分类

1. 系统缺陷
2. 数据缺陷
3. 数据库缺陷
4. 接口缺陷
5. 功能缺陷
6. 安全性缺陷
7. 兼容性缺陷
8. 性能缺陷
9. 界面缺陷
10. 建议

#### 缺陷报告注意事项

1. 尽量保证缺陷可以重现
2. 简洁、准确、完整
3. 一个缺陷报告只写一个缺陷

#### 缺陷书写规范

1. 标题简洁、提供缺陷的本质信息即可
2. 复现的步骤要详细，用数字编号
3. 实际结果要描述清楚复现后的结果
4. 列出期望结果
5. 提供附件
6. 提供严重性属性和其它公司需要填写的属性

注意：要避免一些常见错误

1. 避免使用情绪化语言和强调标点符号
2. 避免使用模糊的词语
3. 避免使用自认为幽默的语言，直接描述问题即可
4. 避免提交不确定的缺陷

#### 缺陷处理流程

![捕获](https://massionter-images-1258860804.cos.ap-guangzhou.myqcloud.com/zcayo/%E6%8D%95%E8%8E%B7.PNG)

#### 缺陷的跟踪

新提交的缺陷为“新建”状态，在确认有效之后变为“打开”状态，开发人员修改后变为“已修复”状态，此时测试人员需要回归测试，如果验证问题已解决，状态为“已解决”，如果问题依然存在，状态为“打开”；如果开发人员认为此缺陷可以延期修改，状态为“延期”；注意此时必须由项目相关人员讨论确定后，才可以延期处理，否则状态继续为“打开”

缺陷的密度：每千行代码的缺陷数，为1000*缺陷总数 / 代码行数

