### TCP和UDP协议

#### TCP的三次握手

![311436_1552561665620_E7A5C9C77901F4FC171124336780AA75](D:\360安全浏览器下载\学习\311436_1552561665620_E7A5C9C77901F4FC171124336780AA75.png)

1. 第一次握手：建立连接时，客户端发送SYN包（SYN=1,Seq=X,Ack=0）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
2. 第二次握手：服务器收到SYN包，必须确认客户的SYN包，同时自己也发送一个SYN+ACK包（SYN=1,Seq=Y,Ack=X+1），此时服务器进入SYN_RECV状态；
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(Seq=X+1,Ack=Y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

#### TCP四次挥手

![311436_1552562623359_52EC3E3B261B21C0A862075DAD224D0F](D:\360安全浏览器下载\学习\311436_1552562623359_52EC3E3B261B21C0A862075DAD224D0F.png)

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

1. 客户端A发送一个FIN+ACK（Fin=,1,Seq=X,Ack=Z），用来关闭客户A到服务器B的数据传送。
2. 服务器B收到这个FIN，它发回一个ACK（Seq=Z,Ack=X+1），确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
3. 服务器B关闭与客户端A的连接，发送一个FIN（Fin=1,Seq=Y,Ack=X）给客户端A。
4. 客户端A发回ACK（Seq=X,Ack=Y）报文确认，并将确认序号设置为收到序号加1。

#### TCP的流量控制

发送和接受方都会维护一个数据帧的序列，这个序列被称作窗口。发送方的窗口大小由接受方确定，目的在于控制发送速度，以免接受方的缓存不够大，而导致溢出，同时控制流量也可以避免网络拥塞

![捕获1](E:\我的电脑\图片\学习\捕获1.PNG)

#### TCP和UDP的区别

1. TCP面向连接的（如打电话要先拨号建立连接）；UDP是无连接的，发送数据之前不需要建立连接
2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道
3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。
4. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）
5. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信
6. TCP首部开销20字节;UDP的首部开销小，只有8个字节

### DNS寻址过程

1. 浏览器先检查自身缓存和操作系统缓存文件`hosts`中有没有被解析过的这个域名对应的ip地址

2. 查找本地DNS解析器缓存

3. 查找填写或分配的首选DNS服务器，称为本地DNS服务器

   （1）如果要查询的域名包含在本地配置区域资源中，此解析具有权威性

   （2）如果要查询的域名不由本地DNS服务器区域解析，但服务器缓存了此网址的映射关系，此解析不具有权威性

4. （1）如果未采用转发模式（迭代），本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后，会判断这个域名（如.com）是谁来授权管理，并返回一个负责该顶级域名服务器的IP，本地DNS服务器收到顶级域名服务器IP信息后，继续向该顶级域名服务器IP发送请求，该服务器如果无法解析，则会找到负责这个域名的下一级DNS服务器（如[http://baidu.com](http://baidu.com/)）的IP给本地DNS服务器，循环往复直至查询到映射，将解析结果返回本地DNS服务器，再由本地DNS服务器返回解析结果

   （2）如果采用转发模式（递归），则此DNS服务器就会把请求转发至上一级DNS服务器，如果上一级DNS服务器不能解析，则继续向上请求

5. 得到目标服务器的IP地址及端口号（http 80端口，https 443端口），会调用系统库函数socket，请求一个TCP流套接字。客户端向服务器发送HTTP请求报文

### IOS七层模型

1. 物理层（Physical Layer）

   主要功能是利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的

2. 数据链路层（Data Link Layer）

   主要功能是通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。该层通常又被分为介质访问控制（MAC）和逻辑链路控制（LLC）两个子层

   （1）MAC子层的主要任务是解决共享型网络中多用户对信道竞争的问题，完成网络介质的访问控制

   （2）LLC子层的主要任务是建立和维护网络连接，执行差错校验、流量控制和链路控制

3. 网络层（Network Layer）：它在下两层的基础上向资源子网提供服务。主要任务是通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。该层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由（即两节点间可能有多条路径）选择问题

4. 传输层（Transport Layer）

   该层是通信子网和资源子网的接口和桥梁，主要任务是向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。传输层的主要功能如下

   （1）传输连接管理：提供建立、维护和拆除传输连接的功能。传输层在网络层的基础上为高层提供“面向连接”和“面向无接连”的两种服务

   （2）处理传输差错：提供可靠的“面向连接”和不太可靠的“面向无连接”的数据传输服务、差错控制和流量控制。在提供“面向连接”服务时，通过这一层传输的数据将由目标设备确认，如果在指定的时间内未收到确认信息，数据将被重发

5. 会话层（Session Layer）

   是用户应用程序和网络之间的接口，主要任务是向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理

6. 表示层（Presentation Layer）

   它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等

7. 应用层（Application Layer）

   它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作

### ![v2-854e3df8ea850c977c30cb1deb1f64db_r](E:\我的电脑\图片\学习\v2-854e3df8ea850c977c30cb1deb1f64db_r.jpg)

REST(Representational State Transfer，代示状态转移)是一种轻量级的Web Service架构，REST架构对资源的操作包括获取、创建、修改和删除资源的操作对应HTTP协议提供的GET、POST、PUT和DELETE方法

简单对象访问协议(SOAP)，JNDI(Java Naming and Directory Interface)

### session、cookie和token

#### session

session的中文翻译是“会话”，当用户打开某个web应用时，便与web服务器产生一次session。服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失

#### cookie

cookie是保存在本地终端的数据。cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的

#### session过程

1. 客户端向服务器请求，发送用户名和密码
2. 服务器生成sessionId，绑定用户数据存储在数据库
3. 服务器返回sessionId给客户端
4. 客户端用cookie存储sessionId，以后的请求都带上这个sessionId
5. 服务器如果收到这个sessionId，那么就去数据库查找用户数据，如果找到了说明验证通过
6. 服务器把验证结果返回客户端

####  cookie 和session的区别

1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
      考虑到安全应当使用session。
3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
      考虑到减轻服务器性能方面，应当使用COOKIE。
4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie

建议：将登陆信息等重要信息存放为SESSION，其他信息如果需要保留，可以放在COOKIE中

#### token

​     token的意思是“令牌”，是用户身份的验证方式，最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库

#### token过程

1. 客户端向服务器请求，发送用户名和密码
2. 服务器根据用户信息通过加密生成token，用户信息包括账号，token过期时间等，具体由服务器自定义。
3. 服务器返回token给客户端
4. 客户端用cookie存储token，以后的请求都带上这个token
5. 服务器把token解密，确认用户信息是否正确，如经过正确就说明验证通过。
6. 服务器把验证结果返回客户端

下面图片显示客户浏览器先登录成功后，服务端将产生的token通过响应头的cookie传给客户浏览器，客户浏览器中保存有cookie，再次访问网址时候，会自动传cookie放在请求头中，将请求头中的token与数据库中的用户信息相互匹配，若匹配成功则实现自动登录

![20181204122406427](D:\360安全浏览器下载\学习\20181204122406427.png)